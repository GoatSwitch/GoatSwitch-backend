import logging
import re
import time

import pytest
from gs_client import GSClient
from gs_common.CodeProject import CodeFile, CodeProject
from gs_common.proto.ut_picker_pb2 import ReturnCode

from dataset.util import load_example_project
from test.utils import MAX_WAIT_TIME, SERVER_URL

# setup logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)


def send_gen_tests(
    source_project: CodeProject,
    test_project: CodeProject = None,
    instruction: str = "",
) -> tuple[CodeProject, str, int]:
    gs_client = GSClient(
        server_url=SERVER_URL,
        max_wait_time=MAX_WAIT_TIME,
        project_name=source_project.display_name,
    )
    gs_client.connect()
    gs_client.send_workflow_generate_tests(source_project, instruction, test_project)
    gs_client.disconnect()

    # check that signalr message did not contain error
    assert gs_client.ut_result[1] != "error", f"error: {gs_client.ut_result[1]}"

    # NOTE: would be much nice to parse as UTPickerResponse, but idk how
    new_test_project = CodeProject.model_validate(gs_client.ut_result[0]["solution"])
    assert new_test_project is not None
    test_output = gs_client.ut_result[0]["test_output"]
    return_code = gs_client.ut_result[0]["return_code"]

    # check that terminal output contains no error
    # assert gs_client.log_terminal_errors == []

    return new_test_project, test_output, return_code


def parse_test_output(test_output: str) -> tuple[int, int, int]:
    match = re.search(r'total="(\d+)" passed="(\d+)" failed="(\d+)"', test_output)
    if match is None:
        raise Exception(f"Cannot parse num passed of test_output: {test_output}")
    else:
        return int(match.group(1)), int(match.group(2)), int(match.group(3))


def test_program(program, language, autofix=False):
    if autofix:
        test_program_with_autofix(program, language)
    else:
        test_program_without_autofix(program, language)


def test_program_without_autofix(program, language):
    # Arrange
    source_project = load_example_project(program, language)

    # Act
    new_test_project, test_output, return_code = send_gen_tests(source_project)

    # Assert
    assert (
        return_code == ReturnCode.SUCCESS
        or return_code == ReturnCode.FAILED_TEST_EXECUTION
    ), f"return_code: {return_code}"
    assert new_test_project is not None
    # check that there are at least X asserts
    n_asserts = 0
    keyword = "Assert."
    for file in new_test_project.files:
        assert isinstance(file, CodeFile)
        if not file.file_name.endswith(".cs"):
            continue
        n_asserts += file.source_code.count(keyword)
    logging.info(f"{n_asserts=}")
    assert n_asserts >= 5

    # check test_output
    n_total, n_passed, n_failed = parse_test_output(test_output)
    logging.info(f"{n_total=}, {n_passed=}, {n_failed=}")
    assert n_total >= 9
    assert n_passed > 5


def test_program_with_autofix(program, language):
    # Arrange
    source_project = load_example_project(program, language)
    test_project = load_example_project(program + "-GSTests", "nunit_unittests_failed")
    instruction = next(
        file.source_code
        for file in test_project.files
        if file.file_name.endswith("test_results.xml")
    )

    n_total_pre, n_passed_pre, n_failed_pre = parse_test_output(instruction)
    print(f"{n_total_pre=}, {n_passed_pre=}, {n_failed_pre=}")

    # Act
    new_test_project, test_output, return_code = send_gen_tests(
        source_project, test_project, instruction
    )

    # Assert
    assert return_code == ReturnCode.SUCCESS, f"return_code: {return_code}"
    assert new_test_project is not None

    # the old test project should have been modified not rewritten
    # check that the new test project contains this string
    id_string = "// NOTE: Generated by GoatSwitch AI"
    assert any(
        id_string in file.source_code for file in new_test_project.files
    ), f"Cannot find '{id_string}' in new test project"

    # check that there are at least X asserts
    n_asserts = 0
    keyword = "Assert."
    for file in new_test_project.files:
        assert isinstance(file, CodeFile)
        if not file.file_name.endswith(".cs"):
            continue
        n_asserts += file.source_code.count(keyword)
    logging.info(f"{n_asserts=}")
    assert n_asserts >= 5

    # check test_output
    n_total, n_passed, n_failed = parse_test_output(test_output)
    logging.info(f"{n_total=}, {n_passed=}, {n_failed=}")
    assert n_total >= n_total_pre
    assert n_passed > n_passed_pre
    assert n_failed == 0


if __name__ == "__main__":
    # pytest.main([__file__, "-s", "--workers", "1"])
    # exit()

    for i in range(20):
        time.sleep(1)
        print("iter: ------------- ", i)
        # test_program("Hashids.net-v112", "dotnetframework")
        # test_program_with_autofix("Hashids.net-v112", "dotnetframework")
        # does not work right now even with 2 autofixes
        # test_program_with_autofix("Crc32.NET-v100", "dotnetframework")
        # test_program("Hashids.net-v112", "dotnet8", autofix=False)
        test_program("QRCoder", "dotnetframework")
        # test_program("Crc32.NET-v100", "dotnetframework")
        # test_program("QRCoder", "dotnet8")
        # test_program("Hashids.net-v112", "dotnetframework")
        exit()
